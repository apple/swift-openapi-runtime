//===----------------------------------------------------------------------===//
//
// This source file is part of the SwiftOpenAPIGenerator open source project
//
// Copyright (c) 2023 Apple Inc. and the SwiftOpenAPIGenerator project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of SwiftOpenAPIGenerator project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import HTTPTypes
#if canImport(Darwin)
import struct Foundation.URL
#else
@preconcurrency import struct Foundation.URL
#endif

/// A type that performs HTTP operations.
///
/// Decouples an underlying HTTP library from generated client code.
///
/// ### Choose between a transport and a middleware
///
/// The ``ClientTransport`` and ``ClientMiddleware`` protocols look similar,
/// however each serves a different purpose.
///
/// A _transport_ abstracts over the underlying HTTP library that actually
/// performs the HTTP operation by using the network. A generated `Client`
/// requires an exactly one client transport.
///
/// A _middleware_ intercepts the HTTP request and response, without being
/// responsible for performing the HTTP operation itself. That's why
/// middlewares take the extra `next` parameter, to delegate making the HTTP
/// call to the transport at the top of the middleware stack.
///
/// ### Use an existing client transport
///
/// Instantiate the transport using the parameters required by the specific
/// implementation. For example, using the client transport for the
/// `URLSession` HTTP client provided by the Foundation framework:
///
///     let transport = URLSessionTransport()
///
/// Create the base URL of the server to call using your client. If the server
/// URL was defined in the OpenAPI document, you find a generated method for it
/// on the `Servers` type, for example:
///
///     let serverURL = try Servers.server1()
///
/// Instantiate the `Client` type generated by the Swift OpenAPI Generator for
/// your provided OpenAPI document. For example:
///
///     let client = Client(
///         serverURL: serverURL,
///         transport: transport
///     )
///
/// Use the client to make HTTP calls defined in your OpenAPI document. For
/// example, if the OpenAPI document contains an HTTP operation with
/// the identifier `checkHealth`, call it from Swift with:
///
///     let response = try await client.checkHealth(.init())
///     switch response {
///         case .ok(let okPayload):
///             // ...
///
///         // Handle any HTTP status code not documented in
///         // your OpenAPI document.
///         case .undocumented(let statusCode, _):
///             // ...
///     }
///
/// The generated operation method takes an `Input` type unique to
/// the operation, and returns an `Output` type unique to the operation.
///
/// > Note: You use the `Input` type to provide parameters such as HTTP request headers,
/// query items, path parameters, and request bodies; and inspect the `Output`
/// type to handle the received HTTP response status code, response header and
/// body.
///
/// ### Implement a custom client transport
///
/// If a client transport implementation for your preferred HTTP library doesn't
/// yet exist, or you need to simulate rare network conditions in your tests,
/// consider implementing a custom client transport.
///
/// For example, to implement a test client transport that allows you
/// to test both a healthy and unhealthy response from a `checkHealth`
/// operation, define a new struct that conforms to the `ClientTransport`
/// protocol:
///
///     struct TestTransport: ClientTransport {
///         var isHealthy: Bool = true
///         func send(
///             _ request: HTTPRequest,
///             body: HTTPBody?,
///             baseURL: URL,
///             operationID: String
///         ) async throws -> (HTTPResponse, HTTPBody) {
///             (
///                 HTTPResponse(status: isHealthy ? .ok : .internalServerError),
///                 HTTPBody()
///             )
///         }
///     }
///
/// Then in your test code, instantiate and provide the test transport to your
/// generated client instead:
///
///     let transport = TestTransport()
///     transport.isHealthy = true // for HTTP status code 200 (success)
///     transport.isHealthy = false // for HTTP status code 500 (failure)
///     let serverURL = try Servers.server1()
///     let client = Client(
///         serverURL: serverURL,
///         transport: transport
///     )
///     let response = try await client.checkHealth(.init())
///     // ...
///
/// Implementing a test client transport is just one way to help test your
/// code that integrates with a generated client. Another is to implement
/// a type conforming to the generated protocol `APIProtocol`, and to implement
/// a custom ``ClientMiddleware``.
public protocol ClientTransport: Sendable {

    func send(
        _ request: HTTPRequest,
        body: HTTPBody?,
        baseURL: URL,
        operationID: String
    ) async throws -> (HTTPResponse, HTTPBody)
}

public protocol ClientMiddleware: Sendable {

    func intercept(
        _ request: HTTPRequest,
        body: HTTPBody?,
        baseURL: URL,
        operationID: String,
        next: @Sendable (HTTPRequest, HTTPBody?, URL) async throws -> (HTTPResponse, HTTPBody)
    ) async throws -> (HTTPResponse, HTTPBody)
}
